import unittest  # Модуль для юнит-тестирования, предоставляет инструменты для создания и запуска тестов
from app import get_currency_rates, index  # Импорт функций get_currency_rates и index из app.py для тестирования
from flask import Flask, request  # Flask для создания тестового приложения, request для работы с данными запросов
from unittest.mock import patch  # Инструмент для мока(тестовые двойники, для имитации поведения зависимостей или функциональности) внешних зависимостей, таких как HTTP-запросы
class TestCurrencyConverter(unittest.TestCase):
    """Класс для тестирования конвертера валют"""
    # Наследуется от unittest.TestCase, чтобы использовать методы для проверки утверждений (assert)
    def setUp(self):
        """Настройка тестового окружения перед каждым тестом"""
        # Метод вызывается автоматически перед каждым тестом для подготовки окружения
        # Создаем Flask-приложение для тестов
        self.app = Flask(__name__)  # Инициализируем Flask-приложение, __name__ — имя текущего модуля
        # Включаем тестовый режим для Flask
        self.app.config['TESTING'] = True  # Тестовый режим отключает обработку ошибок Flask для упрощения тестирования
        # Создаем тестовый клиент для отправки HTTP-запросов
        self.client = self.app.test_client()  # Тестовый клиент имитирует запросы к приложению без запуска сервера
        # Регистрируем маршрут для функции index
        # Связываем URL '/' с функцией index, поддерживающей GET и POST
        self.app.add_url_rule('/', 'index', index, methods=['GET', 'POST'])

    def test_get_currency_rates_fallback(self):
        """Тест получения запасных курсов валют при ошибке API"""
        # Проверяет, что функция get_currency_rates возвращает запасные курсы, если API недоступно
        # Мокаем requests.get, чтобы сымитировать ошибку
        with patch('requests.get') as mocked_get:  # Используем patch для замены requests.get на мок-объект
            # Устанавливаем, что mocked_get будет бросать исключение
            mocked_get.side_effect = Exception("API недоступно")  # Симулируем сбой API
            # Вызываем функцию get_currency_rates
            rates = get_currency_rates()  # Получаем результат выполнения функции
            # Проверяем, что возвращается словарь
            self.assertIsInstance(rates, dict)  # Убеждаемся, что rates — это словарь
            # Проверяем наличие валют
            self.assertIn('USD', rates)  # Проверяем, что ключ 'USD' есть в словаре
            self.assertIn('EUR', rates)  # Проверяем, что ключ 'EUR' есть в словаре
            self.assertIn('RUB', rates)  # Проверяем, что ключ 'RUB' есть в словаре
            self.assertIn('KZT', rates)  # Проверяем, что ключ 'KZT' есть в словаре
            # Проверяем значения запасных курсов
            self.assertEqual(rates['USD'], 1.0)  # Проверяем, что курс USD равен 1.0
            self.assertEqual(rates['EUR'], 0.85)  # Проверяем, что курс EUR равен 0.85
            self.assertEqual(rates['RUB'], 82.0)  # Проверяем, что курс RUB равен 82.0
            self.assertEqual(rates['KZT'], 420.0)  # Проверяем, что курс KZT равен 420.0

    def test_invalid_amount_input(self):
        """Тест обработки некорректной суммы (не число)"""
        # Проверяет, как приложение обрабатывает ввод суммы, которая не является числом
        with self.client as c:  # Используем тестовый клиент в контексте
            # Отправляем POST-запрос с некорректной суммой
            response = c.post('/', data={
                'amount': 'abc',  # Некорректная сумма (строка вместо числа)
                'from_currency': 'USD',  # Исходная валюта
                'to_currency': 'EUR',  # Целевая валюта
                'decimal_places': '2'  # Количество знаков после запятой
            })  # Отправляем POST-запрос на главную страницу
            # Проверяем, что код ответа 200
            self.assertEqual(response.status_code, 200)  # Убеждаемся, что запрос успешен (страница загрузилась)
            # Проверяем наличие сообщения об ошибке
            error_message = "Пожалуйста, введите корректное число"  # Ожидаемое сообщение об ошибке
            self.assertIn(error_message.encode('utf-8'), response.data)  # Проверяем, что сообщение есть в ответе (в байтах UTF-8)

    def test_negative_amount(self):
        """Тест обработки отрицательной или нулевой суммы"""
        # Проверяет, как приложение обрабатывает отрицательную или нулевую сумму
        with self.client as c:  # Используем тестовый клиент в контексте
            # Отправляем POST-запрос с отрицательной суммой
            response = c.post('/', data={
                'amount': '-100',  # Отрицательная сумма
                'from_currency': 'USD',  # Исходная валюта
                'to_currency': 'EUR',  # Целевая валюта
                'decimal_places': '2'  # Количество знаков после запятой
            })  # Отправляем POST-запрос на главную страницу
            # Проверяем, что код ответа 200
            self.assertEqual(response.status_code, 200)  # Убеждаемся, что запрос успешен
            # Проверяем наличие сообщения об ошибке
            error_message = "Введите положительное количество денег"  # Ожидаемое сообщение об ошибке
            self.assertIn(error_message.encode('utf-8'), response.data)  # Проверяем, что сообщение есть в ответе (в байтах UTF-8)

    def test_too_large_amount(self):
        """Тест обработки слишком большой суммы"""
        # Проверяет, как приложение обрабатывает сумму, превышающую 1 миллиард
        with self.client as c:  # Используем тестовый клиент в контексте
            # Отправляем POST-запрос с суммой > 1 миллиарда
            response = c.post('/', data={
                'amount': '1000000001',  # Слишком большая сумма
                'from_currency': 'USD',  # Исходная валюта
                'to_currency': 'EUR',  # Целевая валюта
                'decimal_places': '2'  # Количество знаков после запятой
            })  # Отправляем POST-запрос на главную страницу
            # Проверяем, что код ответа 200
            self.assertEqual(response.status_code, 200)  # Убеждаемся, что запрос успешен
            # Проверяем наличие сообщения об ошибке
            error_message = "Сумма слишком большая для конвертации"  # Ожидаемое сообщение об ошибке
            self.assertIn(error_message.encode('utf-8'), response.data)  # Проверяем, что сообщение есть в ответе (в байтах UTF-8)

    def test_invalid_decimal_places(self):
        """Тест обработки некорректного количества знаков после запятой"""
        # Проверяет, как приложение обрабатывает некорректное значение для decimal_places
        with self.client as c:  # Используем тестовый клиент в контексте
            # Отправляем POST-запрос с некорректным decimal_places
            response = c.post('/', data={
                'amount': '100',  # Корректная сумма
                'from_currency': 'USD',  # Исходная валюта
                'to_currency': 'EUR',  # Целевая валюта
                'decimal_places': 'abc'  # Некорректное значение (строка вместо числа)
            })  # Отправляем POST-запрос на главную страницу
            # Проверяем, что код ответа 200
            self.assertEqual(response.status_code, 200)  # Убеждаемся, что запрос успешен
            # Проверяем наличие сообщения об ошибке
            error_message = "Ошибка при конвертации"  # Ожидаемое сообщение об ошибке
            self.assertIn(error_message.encode('utf-8'), response.data)  # Проверяем, что сообщение есть в ответе (в байтах UTF-8)

if __name__ == '__main__':
    # Проверяем, запущен ли скрипт напрямую (а не импортирован как модуль)
    unittest.main()  # Запускаем все тесты, определенные в классе TestCurrencyConverter